---
layout: post
title:  单例设计模式
subtitle: 	
date:   2017-11-28
author: JP
header-img: img/post-bg-swift.jpg
catalog: true
tags:
- 单例
- 设计模式

---

> 正文

## 一、什么是单例模式 ##

#### 1.生活中的单例
一个男人只能有一个媳妇「正常情况」，一个人只能有一张嘴，通常一个公司只有一个 CEO ，一个狼群中只有一个狼王等等

#### 2.程序中的单例
一句话，就是保证一个类仅有一个实例即可「new 一次」，其实好多人都不把单例当作成一个设计模式，只是当作是一个工具类而已，因为它的确很简单，并且当你面视的时候面视官问你设计模式的时候估计都会说：可以说说你了解的设计模式吗「单例除外」。虽然很简单，但是我们还是要掌握和了解它，并且要深层次的了解它

> 单例模式的定义

单例单例就是单一的实例，单例模式就保证一个类仅有一个实例，并且提供一个可以仿问的全局方法可以访问它

> 单例的应用

- 网站的计数器
- 应用配置
- 多线程池一般也采用单例去设计
- 数据库配置,数据库连接池
- window窗体不能同时出现两个
- 其它等等

##### 1.经典模式

		public class Singleton
		{
		    private static Singleton instance;
		    private Singleton()
		    {
		    }
		    public static Singleton GetInstance()
		    {
		        if (instance==null)
		        {
		            instance=new Singleton();
		        }
		        return instance;
		    }
		}
	

解析如下：

　　1）首先，该Singleton的构造函数必须是私有的，以保证客户程序不会通过new（）操作产生一个实例，达到实现单例的目的；

　　2）因为静态变量的生命周期跟整个应用程序的生命周期是一样的，所以可以定义一个私有的静态全局变量instance来保存该类的唯一实例；

　　3）必须提供一个全局函数访问获得该实例，并且在该函数提供控制实例数量的功能，即通过if语句判断instance是否已被实例化，如果没有则可以同new（）创建一个实例；否则，直接向客户返回一个实例。

　　在这种经典模式下，没有考虑线程并发获取实例问题，即可能出现两个线程同时获取instance实例，且此时其为null时，就会出现两个线程分别创建了instance，违反了单例规则。因此，需对上面代码修改。	

##### 2.多线程下的单例模式

1、Lazy模式（懒汉式）

	public class Singleton
	{
	    private static Singleton instance;
	    private static object _lock=new object();
	    private Singleton()
	    {
	    }
	    public static Singleton GetInstance()
	    {
	        if (instance==null)
	        {
	            lock (_lock)
	            {
	                if(instance==null)
	                {
	                    instance=new Singleton();
	                }
	            }
	        }
	        return instance;
	    }
	}

上述代码使用了双重锁方式较好地解决了多线程下的单例模式实现。先看内层的if语句块，使用这个语句块时，先进行加锁操作，保证只有一个线程可以访问该语句块，进而保证只创建了一个实例。再看外层的if语句块，这使得每个线程欲获取实例时不必每次都得加锁，因为只有实例为空时（即需要创建一个实例），才需加锁创建，若果已存在一个实例，就直接返回该实例，节省了性能开销。

2、饿汉模式

这种模式的特点是自己主动实例。

	public sealed class Singleton
	{
	    private static readonly Singleton instance=new Singleton();
	    private Singleton()
	    {
	    }
	    public static Singleton GetInstance()
	    {
	        return instance;        
	    }
	}

上面使用的readonly关键可以跟static一起使用，用于指定该常量是类别级的，它的初始化交由静态构造函数实现，并可以在运行时编译。在这种模式下，无需自己解决线程安全性问题，CLR会给我们解决。由此可以看到这个类被加载时，会自动实例化这个类，而不用在第一次调用GetInstance()后才实例化出唯一的单例对象。

参考资料：<br>
1.[C#设计模式(1)——单例模式](http://www.cnblogs.com/zhili/p/SingletonPatterm.html)<br>
2.[人人都会设计模式：单例模式--SingleTon](https://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&mid=2651941869&idx=1&sn=daf418bf5f445b856e6828b1d64ee4db&chksm=84fd7909b38af01f972b758ce07f1c2cdbe7fad5c1f868bfaa6d7acbf1b75087d3cb610fb00b&mpshare=1&scene=23&srcid=1115l4KDdG5BNmK2aOGwAKI5#rd)<br>
3.[C#设计模式学习笔记-单例模式](http://www.cnblogs.com/xun126/archive/2011/03/09/1970807.html)<br>
4.[在C#中实现 Singleton](https://msdn.microsoft.com/zh-cn/library/ff650316.aspx)